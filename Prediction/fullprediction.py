# -*- coding: utf-8 -*-
"""FullPrediction.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/17_7nyyOJufSSU0_5Urs3kewBORk9ICLy
"""

import pandas as pd

#load info
team_season = pd.read_csv(r"/content/team_season.csv")
team_season.head()

Y = []
for value in team_season.values:
    won = value[34]
    lost = value[35]
    Y.append(float(won / (won + lost)))
print(len(Y))

print(Y)

import copy

team_season_dropped = copy.deepcopy(team_season)
team_season_dropped.drop(team_season_dropped.columns[[0, 1, 2, 34, 35]], axis=1, inplace=True)
team_season_dropped.head()

print(len(team_season_dropped) == len(Y))

from sklearn.preprocessing import StandardScaler

X = StandardScaler().fit_transform(team_season_dropped)

print(X[1])

print(Y[1])

import matplotlib.pyplot as plt
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import MinMaxScaler
from tensorflow.python.keras.models import Sequential
from tensorflow.python.keras.layers import Dense

x = X
y = Y
y = np.reshape(y, (-1, 1))
scalar_x = MinMaxScaler()
scalar_y = MinMaxScaler()
print(scalar_x.fit(x))
xscale = scalar_x.transform(x)
print(scalar_y.fit(y))
yscale = scalar_y.transform(y)

X_train, X_test, y_train, y_test = train_test_split(xscale, yscale)

model = Sequential()
model.add(Dense(31, input_dim=31, kernel_initializer='normal', activation='relu'))
model.add(Dense(128, activation='relu'))
model.add(Dense(128, activation='relu'))
model.add(Dense(128, activation='relu'))
model.add(Dense(1, activation='linear'))
model.summary()

model.compile(loss='mse', optimizer='adam', metrics=['mse', 'mae'])

history = model.fit(X_train, y_train, epochs=250, batch_size=50, verbose=1, validation_split=0.2)

print(history.history.keys())
# "Loss"
plt.plot(history.history['loss'])
plt.plot(history.history['val_loss'])
plt.title('model loss')
plt.ylabel('loss')
plt.xlabel('epoch')
plt.legend(['train', 'validation'], loc='upper left')
plt.show()

print(history.history.keys())
plt.plot(history.history['mse'])
plt.plot(history.history['mae'])
plt.title('model performance')
plt.ylabel('error')
plt.xlabel('epoch')
plt.legend(['mse', 'mae'], loc='upper left')
plt.show()

X_new = np.array([[-2.2578408616907195, -0.7619484936348196, -2.5780332793928573,
                  -1.9008068681873072, -1.3986096481100645, -1.42322851369181, -3.6418724785872727,
                  -3.9060410970576713, -1.7554032607606425, -1.3943150129620527, -1.3894138552044868,
                  -1.3483989533215142, -0.8749243064663377, -0.4022884310098427, -2.6667544718571463,
                  -1.907681185475232, -1.9270714623297287, -1.8745383118848733,
                  -1.8770428706065658, -1.4066279663766306, -1.4222819925666383, -1.9167216073576925,
                  -1.8937499044421475, -1.925058900708228, -1.4048608587821392, -1.3864975278692442,
                  -1.3857455114766448, -0.925015121858419, -0.4127990174344398, -2.8373837683558767,
                  -1.4360815700998038]])
X_new = scalar_x.transform(X_new)
y_new = model.predict(X_new)
#invert normalize
y_new = scalar_y.inverse_transform(y_new)
X_new = scalar_x.inverse_transform(X_new)
print("X=%s, Predicted=%s" % (X_new[0], y_new[0]))
nn_predictions = []
for value in X:
    X_new = np.array([value])
    X_new = scalar_x.transform(X_new)
    y_new = model.predict(X_new)
    #invert normalize
    y_new = scalar_y.inverse_transform(y_new)
    X_new = scalar_x.inverse_transform(X_new)
    nn_predictions.append(y_new[0])
    #print(ynew[0])

team_arr = (team_season.team == "BOS").values

year_arr = (team_season.year == int("1946")).values

count = 0
index = -1
for value in team_arr:
    if team_arr[count]:
        if year_arr[count]:
            index = count
    count = count + 1
print(index)

X = StandardScaler().fit_transform(team_season_dropped)

team_season_dropped = X
print(X[index].tolist())

#save neural network here
model.save('NNpredictionModel.h5')

X_new = np.array([team_season_dropped[index].tolist()])
X_new = scalar_x.transform(X_new)
y_new = model.predict(X_new)
#invert normalize
y_new = scalar_y.inverse_transform(y_new)
X_new = scalar_x.inverse_transform(X_new)
print("X=%s, Predicted=%s" % (X_new[0], y_new[0]))

neural_Network_Results = []
for value in team_season_dropped:
    X_new = np.array([value.tolist()])
    X_new = scalar_x.transform(X_new)
    y_new = model.predict(X_new)
    #invert normalize
    y_new = scalar_y.inverse_transform(y_new)
    X_new = scalar_x.inverse_transform(X_new)
    # print(ynew[0])
    neural_Network_Results.append(y_new[0])

print(len(neural_Network_Results))

from sklearn import linear_model

X = X
y = Y
lm = linear_model.LinearRegression()
lin_model = lm.fit(X, y)
multi_lin_predictions = lin_model.predict(X)
print(multi_lin_predictions)

from math import exp

print("Enter the first team's name: ")
team_1_name = input() #input from user
print("Enter the year for the first team: ")
year_1 = input() # input from user

print("Enter the second team's name: ")
team_2_name =  input() #input from user
print("Enter the year for the second team: ")
year_2 = input() # input from user

def getSquareRoot():
    team_arr = (team_season.team == str(team_1_name).upper())
    year_arr = (team_season.year == int(year_1)).values

    count = 0
    index = -1
    for _ in team_arr:
        if (team_arr[count] == True):
            if (year_arr[count] == True):
                index = count
        count = count + 1


    print(index)
    print(team_season_dropped[index].tolist())

    X_new = np.array([team_season_dropped[index].tolist()])
    LM_X = X_new
    X_new = scalar_x.transform(X_new)

    y_new = model.predict(X_new)
    #invert normalize
    y_new = scalar_y.inverse_transform(y_new)
    X_new = scalar_x.inverse_transform(X_new)
    print("X=%s, Predicted=%s" % (X_new[0], y_new[0]))

    team2_arr = (team_season.team == str(team_2_name).upper()).values

    year2_arr = (team_season.year == int(year_2)).values

    count = 0
    index2 = -1
    for _ in team2_arr:
      if team2_arr[count]:
        if year2_arr[count]:
            index2 = count
      count = count + 1
    print(index2)
    print(team_season_dropped[index2].tolist())

    X_new2 = np.array([team_season_dropped[index2].tolist()])
    LMX_2 = X_new2
    X_new2 = scalar_x.transform(X_new2)
    y_new2 = model.predict(X_new2)
    #invert normalize
    y_new2 = scalar_y.inverse_transform(y_new2)
    X_new2 = scalar_x.inverse_transform(X_new2)
    print("X=%s, Predicted=%s" % (X_new2[0], y_new2[0]))

    prob1 = exp(float(y_new[0][0])) / (exp(float(y_new[0][0])) + exp(float(y_new2[0][0])))
    print(prob1)

    prob2 = exp(float(y_new2[0][0])) / (exp(float(y_new[0][0])) + exp(float(y_new2[0][0])))
    print(prob2)

    print('For the Neural Network...')
    print('The normalized probability for team one winning is: ' + str(prob1))
    print('The normalized probability for team two winning is: ' + str(prob2))

    print("LM prediction is" + str(multi_lin_predictions[index]))

    LM_Pred_1 = float(multi_lin_predictions[index])
    LM_Pred_2 = float(multi_lin_predictions[index2])

    normalized_LM_1 = exp(LM_Pred_1) / (exp(LM_Pred_1) + exp(LM_Pred_2))
    print(normalized_LM_1 )

    normalized_LM_2 = exp(LM_Pred_2) / (exp(LM_Pred_1) + exp(LM_Pred_2))
    print(normalized_LM_2 )

    print('For the Multiple Linear Regression Model... ')

    print('The normalized probability for team one winning is: '+str(normalized_LM_1))
    print('The normalized probability for team two winning is: '+str(normalized_LM_2))


    final_team1 = prob1 + normalized_LM_1
    final_team2 = prob2 + normalized_LM_2

    Final_normalized_LM_1 = exp(final_team1) / (exp(final_team1) + exp(final_team2))
    print(normalized_LM_1 )

    Final_normalized_LM_2 = exp(final_team2) / (exp(final_team1) + exp(final_team2))
    print(normalized_LM_2 )


    print('For the Ensemble of Both Models...')

    print('The normalized probability for team one winning is: '+str(Final_normalized_LM_1))

    print('The normalized probability for team two winning is: ' + str(Final_normalized_LM_2))


    winner = ""
    if float(Final_normalized_LM_1)>float(Final_normalized_LM_2):
        winner = "The Ensemble result shows that team 1 wins!"
    elif float(Final_normalized_LM_2) > float(Final_normalized_LM_1):
        winner = "The Ensemble result shows that team 2 wins!"

    print(winner)

getSquareRoot()

from sklearn import linear_model
y = Y
lm = linear_model.LinearRegression()
model = lm.fit(X,y)
multi_lin_predictions = lm.predict(X)
print(multi_lin_predictions[1])

lin_regr = linear_model.LinearRegression()
lin_regr.fit(X, y)
predicted_values = []
count = 0
for i in (X):
 lin_predicted_prob = lin_regr.predict([i])
 predicted_values.append(lin_predicted_prob)

from sklearn.preprocessing import StandardScaler
# Standardizing the features
x = StandardScaler().fit_transform(X)
from sklearn.decomposition import PCA
pca = PCA(n_components=2)
principalComponents = pca.fit_transform(x)
principalDf = pd.DataFrame(data = principalComponents, columns = ['principal component 1', 'principal component 2'])
from sklearn import linear_model
x = principalDf
y = Y
lin_regr = linear_model.LinearRegression()
lin_regr.fit(x.values, y)
simple_LM = []
count = 0
for i in x.values:
 lin_predicted_prob = lin_regr.predict([i])
 simple_LM.append(lin_predicted_prob)

from sklearn.metrics import mean_squared_error
from sklearn.metrics import mean_absolute_error
mseSLR = mean_squared_error(np.array(simple_LM), y)
mseMLR = mean_squared_error(np.array(multi_lin_predictions), y)
mseNN = mean_squared_error(np.array(neural_Network_Results), y)
maeSLR = mean_absolute_error(np.array(simple_LM), y)
maeMLR = mean_absolute_error(np.array(multi_lin_predictions), y)
maeNN = mean_absolute_error(np.array(neural_Network_Results), y)
print("The Mean Squared Error for the Simple Linear Regression model is ",mseSLR)
print("The Mean Absolute Error for the Simple Linear Regression model is ",maeSLR)
print("The variance for the Simple Linear Prediction Model is ",np.var(simple_LM))
print("\nThe Mean Squared Error for the Multiple Linear Regression model is ",mseMLR)
print("The Mean Absolute Error for the Multiple Linear Regression model is ",maeMLR)
print("The variance for the Multiple Linear Prediction Model is ",np.var(multi_lin_predictions))
print("\nThe Mean Squared Error for the Probabilistic Regression Neural Network is ",mseNN)
print("The Mean Absolute Error for the Probabilistic Regression Neural Network is ",maeNN)
print("The variance for the Probabilistic Regression Neural Network is ",np.var(neural_Network_Results))